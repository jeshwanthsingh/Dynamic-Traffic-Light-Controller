
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <string.h>

#define BUFFER_SIZE 177
#define READEND 0
#define WRITEEND 1

int main(int argc, char* argv[]) {
    char *prompt = "> ";  // Default prompt

    // If a custom prompt is provided, use it
    if (argc > 1) {
        prompt = argv[1];
    }

    char line[BUFFER_SIZE];  // Store user input
    char *commands[BUFFER_SIZE];  // Store individual commands separated by pipes
    char *arguments[BUFFER_SIZE][BUFFER_SIZE];  // Store arguments for each command
    int command_count;  // Number of commands parsed

    while (1) {
        printf("%s", prompt);  // Print prompt
        fflush(stdout);

        if (fgets(line, sizeof(line), stdin) == NULL) {
            // Handle EOF (Ctrl-D)
            if (feof(stdin)) {
                printf("Exiting shell...\n");
                break;
            } else {
                perror("Error reading input");
                exit(1);
            }
        }

        // Handle empty lines
        if (strcmp(line, "\n") == 0) {
            printf("Error: Empty command. Please enter a command.\n");
            continue;
        }

        // Handle exit command
        if (strcmp(line, "exit\n") == 0) {
            printf("Exiting shell...\n");
            break;
        }

        // Parse input commands separated by pipes
        char *token;
        int command_index = 0;
        token = strtok(line, "|");
        while (token != NULL) {
            commands[command_index] = token;
            token = strtok(NULL, "|");
            command_index++;
        }
        command_count = command_index;  // Total number of commands

        // Parse arguments for each command
        for (int i = 0; i < command_count; i++) {
            int arg_index = 0;
            token = strtok(commands[i], " \t\n");  // Split by spaces or tabs
            while (token != NULL) {
                arguments[i][arg_index] = token;
                token = strtok(NULL, " \t\n");
                arg_index++;
            }
            arguments[i][arg_index] = NULL;  // Null-terminate the argument list
        }

        // Create pipes
        int pipes[command_count - 1][2];
        for (int i = 0; i < command_count - 1; i++) {
            if (pipe(pipes[i]) == -1) {
                perror("pipe");
                exit(EXIT_FAILURE);
            }
        }

        // Fork processes for each command
        for (int i = 0; i < command_count; i++) {
            pid_t pid = fork();
            if (pid == -1) {
                perror("fork");
                exit(EXIT_FAILURE);
            } else if (pid == 0) {
                // Child process

                // Redirect input/output for pipes
                if (i > 0) {
                    // If not the first command, get input from the previous pipe
                    dup2(pipes[i - 1][READEND], STDIN_FILENO);
                }
                if (i < command_count - 1) {
                    // If not the last command, send output to the next pipe
                    dup2(pipes[i][WRITEEND], STDOUT_FILENO);
                }

                // Close all pipe ends
                for (int j = 0; j < command_count - 1; j++) {
                    close(pipes[j][READEND]);
                    close(pipes[j][WRITEEND]);
                }

                // Execute the command
                execvp(arguments[i][0], arguments[i]);
                perror("execvp failed");
                exit(EXIT_FAILURE);  // If execvp fails, exit child process
            }
        }

        // Parent process closes pipes and waits for children to finish
        for (int i = 0; i < command_count - 1; i++) {
            close(pipes[i][READEND]);
            close(pipes[i][WRITEEND]);
        }

        // Wait for all child processes to finish
        for (int i = 0; i < command_count; i++) {
            int status;
            wait(&status);
            printf("Child %d exited with status %d\n", i, WEXITSTATUS(status));
        }
    }

    return 0;
}
